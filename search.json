[
  {
    "objectID": "posts/mastering-llm_week_1/index.html",
    "href": "posts/mastering-llm_week_1/index.html",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "",
    "text": "I have rephrased the quotes for better readability, and enriched some of the content with additional information."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#start-simple",
    "href": "posts/mastering-llm_week_1/index.html#start-simple",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Start Simple",
    "text": "Start Simple\n\n\nDo not start by trying to fine-tune but with prompt engineering and retrieval augmented generation (RAG)\nUse OpenAI, Claude, etc.\n“Vibe-checks” are okay in the beginning\nWrite simple tests and assertions\nShip fast"
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#evaluations-are-central",
    "href": "posts/mastering-llm_week_1/index.html#evaluations-are-central",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Evaluations are Central",
    "text": "Evaluations are Central\nhttps://hamel.dev/blog/posts/evals/"
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#when-to-fine-tune",
    "href": "posts/mastering-llm_week_1/index.html#when-to-fine-tune",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "When to Fine-Tune",
    "text": "When to Fine-Tune\n\nIf you have a prompt that resembles a programming language with numerous conditional statements, it’s an indication that fine-tuning might be beneficial.\nAdditionally, because of the diverse types of examples and various edge cases, it is challenging to cover all possibilities with just a few examples. However, there are strategies to enhance these few-shot examples. For instance, you could use RAG and maintain a database of different examples, making the few-shot examples dynamic. This approach can sometimes be effective.\nThese are some indicators to consider when evaluating the problem itself.\nHamel Husain\n\n\nData Privacy\nFine-tuning allows you to use private data to customize a model without exposing sensitive information to third-party services.\n\n\nQuality vs Latency Trade-off\nWhile using and/or generating fewer tokens can reduce latency, a fine-tuned model may also become so specialized that it limits its ability to perform other tasks.\n\n\nExtremely Narrow Problem\nFor very specialized tasks, general models may not perform adequately. Fine-tuning can help to address these issues.\n\n\nWhen Prompt Engineering Becomes Impractical\nFor complex tasks that require detailed prompts with many conditions, prompt engineering can become inefficient. In such cases, fine-tuning can be an effective solution."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#fine-tuning-vs-rag",
    "href": "posts/mastering-llm_week_1/index.html#fine-tuning-vs-rag",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Fine-Tuning vs RAG",
    "text": "Fine-Tuning vs RAG\nOne does not replace the other. They are two different things.\nThey can be complementary, though. You could use a fine-tuned model to generate better answers with your RAG system."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#preparing-your-data",
    "href": "posts/mastering-llm_week_1/index.html#preparing-your-data",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Preparing your Data",
    "text": "Preparing your Data\nGet as much data as possible (prompt/output pairs). Ultimately, it will often be a matter of time and cost.\n\nConsistent Template\nIt is paramount to clean and have a consistent template for your data."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#synthetic-data",
    "href": "posts/mastering-llm_week_1/index.html#synthetic-data",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Synthetic Data",
    "text": "Synthetic Data\n\nUse the most powerful model to generate synthetic data. To avoid any legal issues, Mistral Large seems quite permissive in its terms and conditions.\nHamel Husain\n\nBut you do you. OpenAI, Anthropic, Google, and the other all used stolen data to train their models while legislating against their intellectual property being open source.\nThis was not in the course, but I think it might be relevant regarding the intellectual property: A short course on OSS Licensing for Research and Education.\nYou probably know what you are doing."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#base-models-vs-instruct-models",
    "href": "posts/mastering-llm_week_1/index.html#base-models-vs-instruct-models",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Base Models vs Instruct Models",
    "text": "Base Models vs Instruct Models\n\nAn instruction tuned model is a base model that has been fine-tuned to speak with you in a chat like manner.\nHamel Husain\n\nWhich one to choose will depend on the problem you are trying to solve with fine-tuning. Basically, if you’re not building a chatbot, you might not need an instruct model."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#which-size-to-choose",
    "href": "posts/mastering-llm_week_1/index.html#which-size-to-choose",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Which Size to Choose",
    "text": "Which Size to Choose\nChoosing the right model size is crucial as it affects both performance and operational costs.\nTry the 7B range models first, but you should develop an intuition with experience. Is the task something a small model can do? Does it require more “reasoning”?\n\nA larger model will cost more and be harder to host. I only fine-tune when it’s a very narrow problem, and where I think it’s going to fit in a small model.\nHamel Husain"
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#manage-user-expectations",
    "href": "posts/mastering-llm_week_1/index.html#manage-user-expectations",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Manage User Expectations",
    "text": "Manage User Expectations\n\nThe “Ask me anything” problem\n9 out of 10 people will ask you to build a chat bot: don’t do it\nBe skeptical of general chat bot\nFigure out how to have a better scope of the problem\n\nThe “Ask Me Anything” approach should be avoided because it sets unrealistic expectations for users.\nMaintaining such a broad scope is not only challenging but also impractical, as it requires the chatbot to understand and process a wide range of inputs. Instead, it is better to define a specific scope right from the start.\nExamples of why you should not build general chatbots:\n\nDPD error caused chatbot to swear at customer\nAir Canada has to honor a refund policy its chatbot made up\nBelgian man dies by suicide following exchanges with chatbot"
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#establish-standards-for-ideal-promptoutput-pairs",
    "href": "posts/mastering-llm_week_1/index.html#establish-standards-for-ideal-promptoutput-pairs",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "Establish Standards for Ideal Prompt/Output Pairs",
    "text": "Establish Standards for Ideal Prompt/Output Pairs\nDon’t mix “okay” answers with “great” ones in your dataset. You should have a clear distinction between them.\nIt is hard to write great answers, but we are good at evaluating which ones we prefer. There are many algorithms to implement those preferences. Currently, the one that seems to work best is Direct Preference Optimization (DPO).\nRemark: the 23rd of May, 2024, an article was published on a new algorithm found to be both simpler and more effective than DPO: Simple Preference Optimization (SimPO). This is very new at the time of writing (25th of May, 2024), so we will have to wait and see how it really performs.\n\nWhat is DPO?\nBasically, instead of linking a single output to a prompt, you will create a dataset with a prompt and a preference between two outputs: a chosen response and a rejected response.\nSee more:\n\nThe original article on the DPO algorithm (Rafailov et al., 2023).\nA practical example of DPO with the TRL library from HuggingFace\n\n\n\nPractical Application and Comparison of DPO\nThe use case was to automate responses to incoming emails. Here are the results of the blinded comparisons (ordered from best to worst):\n\nDPO\nHuman Agent\nSupervised Fine-Tuning on Mistral\nGPT-4\n\nDPO consistently produced “super human” responses in comparison to the other methods."
  },
  {
    "objectID": "posts/mastering-llm_week_1/index.html#references",
    "href": "posts/mastering-llm_week_1/index.html#references",
    "title": "Week 1: When and Why to Fine-Tune an LLM",
    "section": "References",
    "text": "References\n\nYour AI Product Needs Evals\nA short course on OSS Licensing for Research and Education\nDPD error caused chatbot to swear at customer\nAir Canada has to honor a refund policy its chatbot made up\nBelgian man dies by suicide following exchanges with chatbot\nSimPO: Simple Preference Optimization with a Reference-Free Reward (Meng et al., 2024)\nDirect Preference Optimization: Your Language Model is Secretly a Reward Model (Rafailov et al., 2023)\nA practical example of DPO with the TRL library from HuggingFace"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Vim: Open the URL Nearest to the Cursor in a Web Browser\n\n\n\n\n\n\nvim\n\n\nworkflow\n\n\n\nImprove your Vim workflow by opening the URL nearest to the cursor in your web browser with a simple keybind. This blog post provides a step-by-step guide on setting up custom scripts and configuring Vim to achieve this functionality.\n\n\n\n\n\nJun 3, 2024\n\n\n5 min\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1: When and Why to Fine-Tune an LLM\n\n\n\n\n\n\nmastering-llm\n\n\n\nMy notes for the first week of the Mastering LLMs conference hosted by Hamel Husain and Dan Becker.\n\n\n\n\n\nMay 26, 2024\n\n\n5 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "The elegance in this picture has been playfully elevated with AI.\n\nA long time ago, I earned a degree in psychology, specializing in cognitive and affective science, without pursuing a career in this field.\nCurrently, my interests are centered on AI/ML.\nThis website serves as a platform for publishing some of my notes."
  },
  {
    "objectID": "posts/vim-url-opener/index.html",
    "href": "posts/vim-url-opener/index.html",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "",
    "text": "You can easily open a URL in your web browser with a simple keybind right from Vim. The common practice is to use gx as the keybind. However, you need to place the cursor exactly under the URL to open it.\nThat’s why I wrote a small script to improve this workflow: it extracts the URL nearest to the cursor, so that you don’t have to place the cursor exactly under the URL anymore.\nIt also works for Windows via WSL."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#installation",
    "href": "posts/vim-url-opener/index.html#installation",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Installation",
    "text": "Installation\nI created a GitHub repository where you can find the scripts, the Vim function, and a shorter version of the instructions below."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#usage",
    "href": "posts/vim-url-opener/index.html#usage",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Usage",
    "text": "Usage\nTo open a URL in your web browser, just place the cursor near the URL and press gx. There is no need to have your cursor exactly under the URL."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#setup",
    "href": "posts/vim-url-opener/index.html#setup",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Setup",
    "text": "Setup\nThis is not a Vim plugin but a set of Unix filters following the philosophy: “Do one thing and do it well.”\nThis workflow is made of three components:\n\na Bash script (to call the web browser);\na Python script (to extract the URL nearest to the cursor);\na Vim function and a keybind (to call the scripts)."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#adding-the-scripts-to-your-path",
    "href": "posts/vim-url-opener/index.html#adding-the-scripts-to-your-path",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Adding the Scripts to Your PATH",
    "text": "Adding the Scripts to Your PATH\nThe two scripts should be in your PATH. This environment variable contains a list of directories in which the shell looks for executables.\nIf you don’t have a custom directory for your scripts, you can use /usr/local/bin. Ensure that the scripts are executable by running chmod +x /path/to/script.\n\nCreating a Custom Directory for Your Scripts\nPersonally, I use ~/.scripts for my custom scripts.\nAdding a directory to your PATH environment variable is done by adding the following line to your .bashrc or .zshrc:\nexport PATH=\"/path/to/your/directory:$PATH\"\nThen, source your .bashrc or .zshrc file:\nsource ~/.bashrc\nOr initialize a new instance of your shell:\nexec -l $SHELL"
  },
  {
    "objectID": "posts/vim-url-opener/index.html#bash-script-calling-your-web-browser",
    "href": "posts/vim-url-opener/index.html#bash-script-calling-your-web-browser",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Bash Script: Calling your Web Browser",
    "text": "Bash Script: Calling your Web Browser\nThis script just call your web browser’s executable with a URL as an argument. If you’re using WSL and Brave, the script should look like this:\n#!/bin/bash\n\n/mnt/c/Program\\ Files/BraveSoftware/Brave-Browser/Application/brave.exe \"$1\" 2&gt; /dev/null &\nAdjust the path according to your web browser and operating system.\nI named the script brave, but you can name it whatever you want. Just remember to change the name in the Vim function."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#python-script-extract-the-url-nearest-to-the-cursor",
    "href": "posts/vim-url-opener/index.html#python-script-extract-the-url-nearest-to-the-cursor",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Python Script: Extract the URL Nearest to the Cursor",
    "text": "Python Script: Extract the URL Nearest to the Cursor\nLike the Bash script, place the code below in an executable file within your PATH. I named it extract_nearest_url.\n#!/usr/bin/python3\n\nimport re\nimport sys\n\n\ndef main():\n    line = \" \".join(sys.argv[1:-1]) if len(sys.argv) &gt; 1 else \"\"\n    try:\n        cursor_pos = int(sys.argv[-1])\n    except ValueError:\n        sys.exit(\"Error: Cursor position must be an integer\")\n    url = extract_nearest_url(line, cursor_pos)\n    print(url, end=\"\")  # Print without additional newline\n\n\ndef extract_nearest_url(line, cursor_pos):\n    # Regular expression to extract URLs\n    url_patterns = (\n        r\"\\[.*?\\]\\((\\S+?)\\)\",  # Markdown link\n        r\"&lt;(\\S+?)&gt;\",  # Angle brackets\n        r\"\\\\href\\{(\\S+?)\\}\\{.*?\\}\",  # LaTeX \\href{}{}\n        r\"(http[s]?://\\S+)\",  # Plain URLs with protocol\n        r\"(\\b\\S+\\.\\S+)\\b\",  # Plain URLs without protocol\n    )\n    pattern = \"|\".join(url_patterns)\n    matches = re.finditer(pattern, line)\n\n    nearest_url = None\n    min_distance = float(\"inf\")\n\n    # Extract URL\n    for match in matches:\n        url = next((group for group in match.groups() if group), None)\n\n        # Calculate distances to cursor position\n        start_pos = match.start()\n        end_pos = match.end()\n        distance = min(abs(cursor_pos - start_pos), abs(cursor_pos - end_pos))\n\n        # Update nearest URL\n        if distance &lt; min_distance:\n            min_distance = distance\n            # Clean the URL by removing any trailing punctuation and whitespace\n            cleaned_url = re.sub(r\"[),.\\s]*$\", \"\", url)\n            nearest_url = cleaned_url\n\n    return nearest_url if nearest_url else \"\"\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "objectID": "posts/vim-url-opener/index.html#vim-function-and-keybind",
    "href": "posts/vim-url-opener/index.html#vim-function-and-keybind",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Vim Function and Keybind",
    "text": "Vim Function and Keybind\nAdd the following code to your .vimrc:\n\" This function opens the URL nearest to the cursor in Brave \nfunction! OpenURLNearestToCursor()\n  \" Get the current line and column\n  let l:line = getline('.')\n  let l:col = col('.')\n\n  \" Extract the URL nearest to the cursor\n  let l:escaped_line = shellescape(l:line)\n  let l:command = 'extract_nearest_url ' . l:escaped_line . ' ' . l:col\n  let l:cleaned_url = system(l:command)\n\n  \" If a URL has been found, open it in Brave\n  if l:cleaned_url != ''\n      silent exec \"!brave \" . fnameescape(l:cleaned_url)\n      redraw!\n  endif\nendfunction\n\n\" Bind the function to the `gx` key in normal mode\nnnoremap gx :call OpenURLNearestToCursor()&lt;CR&gt;\nNotice that the function calls the extract_nearest_url script and the brave script on lines 5 and 9 respectively. If you named them differently, you should change the names in the function.\nFinally, on the last line, you can see the keybind gx. You can change it to whatever you want."
  },
  {
    "objectID": "posts/vim-url-opener/index.html#conclusion",
    "href": "posts/vim-url-opener/index.html#conclusion",
    "title": "Vim: Open the URL Nearest to the Cursor in a Web Browser",
    "section": "Conclusion",
    "text": "Conclusion\nThis workflow is an improvement over the ordinary gx keybind. You don’t have to place the cursor exactly under the URL anymore. It’s a small change, but it’s pleasant to use."
  }
]